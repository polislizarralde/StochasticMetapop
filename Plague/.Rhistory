set_num_threads(1)
result <- run(model = model)
# Cumulative deaths
traj_D <- trajectory(model = result, compartments = "D")
# Show the points per node
View(traj_D)
# Plot a specific trajectory
ggplot(traj_D) + geom_line(aes(x = time, y = D, color = factor(node)))
# Infected
traj_I <- trajectory(model = result, compartments = "I")
# Show the points per node
View(traj_I)
# Plot a specific trajectory
ggplot(traj_I) + geom_line(aes(x = time, y = I, color = factor(node)))
library(SimInf)
library(tools)
library(dplyr)
library(ggplot2)
library(readr) # for read csv files
if (!require(tidyverse)) {
install.packages("tidyverse")
}
# Load tidyverse
library(tidyverse)
# set the directory to find the csv in the folder data
setwd("~/Documents/GitHub/StochasticMetapop/Plague")
data_cluster <- read_csv("data/Ystad_group.csv")
beginDaysPlague <- data_cluster$BeginDaysPlague
endDaysPlague <- data_cluster$EndDaysPlague
parish_names <- data_cluster$ParishName
patchPop <- data_cluster$BEF1699
maxDays <- max(endDaysPlague)
# data
class_plague <- data_cluster$plague
cum_deaths <- data_cluster$VictimsNumber
# Importing the file with the gravitational term Ni*Nj/dij^2
grav_matrix <- read_csv("data/gravitational.csv")
colnames(grav_matrix) <- parish_names
weight_matrix <- as.matrix(grav_matrix)
# Fixing the file to compute the distance between polygons
#data_cluster <- (data_cluster, centroid, c("lat","long"), sep = ",", remove = TRUE, convert = TRUE)
View(data_cluster)
# generating the initial conditions for the model
npatches <- length(parish_names)
S0 <- rep(0, npatches) # nolint: object_name_linter.
E0 <- rep(0, npatches)
R0 <- rep(0, npatches)
D0 <- rep(0, npatches)
I0 <- rep(0, npatches)
I0[1] <- 1.0
for (i in 1:npatches) {
S0[i] <- patchPop[i] - E0[i] - I0[i] - R0[i]
}
u0 <- data_frame(
S0 = S0,
E0 = E0,
I0 = I0,
R0 = R0,
D0 = D0
)
# patchPop <- function(df,
#                      column_pop = 'BEF1699',
#                      column_name = 'ParishName'
#                     )
#                     {patchNames <- unique(df[[column_name]])
#                      patchPop <- sapply(patchNames, function(name)
#                                  {unique_pop <- unique(df[df[[name]] == name, column_pop])
#                                   if(length(unique_pop) > 0){
#                                     return(unique_pop[1]) # return only the first unique pop value
#                                   } else {
#                                     return(NA)
#                                   }
#                                   })
#                      return(patchPop)
# }
# pop_values <- patchPop(data_cluster, data_cluster$BEF1699, data_cluster$ParishName)
# View(pop_values)
# patchPop(data_cluster = data_cluster)
transitions <- c(
"S-> beta*S*I/(S+E+I+R) -> E",
"E -> sigma*E -> I",
"I -> gamma*(1-mu)*I -> R",
"I -> (gamma*mu)*I -> D"
)
compartments <- c("S", "E", "I", "R", "D")
parameters <- c("beta", "mu")
colnames(u0) <- compartments
tspan <- seq(from = 1, to = maxDays + 20, by = 7)
#EMatrix (#compartments x #events). For each column vector j we put 1 if the compartment
# participated in the event j, otherwise zero.
E <- matrix(
c(0, 1, 1, 0, 0),
nrow = 5,
ncol = 1,
dimnames = list(c("S", "E", "I", "R", "D"),
c("event1"))
)
# Create an external transfer event to move exposed or infected individuals
# from node 1 (Ystad) to other nodes every seven days (tspan)
list_of_events1 <- lapply(tspan,
function(t) {
infect <- data.frame(
event = "extTrans",
time = t,
node = 1,
dest = 2:npatches,
n = 0,
proportion = 0.05,
select = 1,
shift = 0
)
})
# Create an external transfer event to move exposed or infected individuals
# from node 1 (Ystad) to other nodes starting seven days after the initial plague period in each node and every seven days
# for(parish_name in data_cluster$ParishName[-1]) {
#   parish_events <- list()
#   begin_parish_name <-
#     lapply(data_cluster$ParishName, function(x) {
#       data_cluster$BeginDaysPlague[data_cluster$ParishName == x]
#     })
#   end_parish_name <-
#     lapply(data_cluster$ParishName, function(x) {
#       data_cluster$EndDaysPlague[data_cluster$ParishName == x]
#     })
#
#
#   }
# Create an external transfer event to move exposed or infected individuals
# from node 1 (Ystad) to other nodes starting seven days after the initial plague
# period in Ystad and every seven days until seven days before the end period in Ystad
data_init_node <- subset(data_cluster, ParishName == "YSTAD")
initial_time <- data_init_node$BeginDaysPlague[1]
final_time <- data_init_node$EndDaysPlague[1]
for (i in 2:npatches) {
infect_event <-
lapply(seq(from = initial_time + 7, to = final_time, by = 7),
function(t) {
infect <- data.frame(
event = "extTrans",
time = t,
node = 1,
dest = 2:npatches,
n = 0,
proportion = grav_matrix$YSTAD[i],
select = 1,
shift = 0
)
})
}
events <- do.call(rbind, infect_event)
local_parameters <- data.frame(beta = (runif(npatches)),
mu = runif(npatches))
model <- mparse(
transitions = transitions,
compartments = compartments,
gdata = c(sigma = 0.17 , gamma = 0.4),
ldata = local_parameters,
u0 = u0,
E = E,
events = events,
tspan = 1:maxDays + 20
)
set.seed(123)
set_num_threads(1)
result <- run(model = model)
# Cumulative deaths
traj_D <- trajectory(model = result, compartments = "D")
# Show the points per node
View(traj_D)
# Plot a specific trajectory
ggplot(traj_D) + geom_line(aes(x = time, y = D, color = factor(node)))
# Infected
traj_I <- trajectory(model = result, compartments = "I")
# Show the points per node
View(traj_I)
# Plot a specific trajectory
ggplot(traj_I) + geom_line(aes(x = time, y = I, color = factor(node)))
View(Ystad_group)
View(Ystad_group)
#
# A minimal install for groundhog (package management that allows for reproducibility)
# and conflicted (guards against packages overwriting each others' functions in the main namespace)
#
#install.packages("groundhog")
library(groundhog)
pkgs <- c("conflicted","SimInf","readxl","dplyr","lubridate","ggplot2","mlrMBO","DiceKriging","rgenoud")
groundhog.library(pkgs, "2023-04-30")
#install.packages("sf")
#install.packages("spdep")
#install.packages("lwgeom")
#install.packages("readr")
library(sf)
library(spdep)
library(lwgeom)
library(tidyr)
library(readr)
#install.packages("sf")
#install.packages("spdep")
#install.packages("lwgeom")
#install.packages("readr")
library(sf)
library(spdep)
library(lwgeom)
library(tidyr)
library(readr)
# I haven't filtered out any parishes, and you might want to.
counties_shp <- st_read("data/ParishesScania.shp")
counties_shp <- st_set_crs(counties_shp,st_crs(3035))
counties_shp
plot(counties_shp)
table(st_is_valid(counties_shp))
counties_shp_clean <- st_make_valid(counties_shp, reason = TRUE)
plot(counties_shp_clean)
centroids <- st_centroids(counties_shp_clean)
centroids <- st_centroid(counties_shp_clean)
centroids
shared_borders <- st_touches(counties_shp_clean, sparse = FALSE)
border_length <- function(i, j, counties_shp_clean) {
if (shared_borders[i, j]) {
intersection <- st_intersection(counties_shp_clean[i,], counties_shp_clean[j,])
return(st_length(intersection))
}
return(0)
}
n <- nrow(counties_shp_clean)
# Fill the a dataframe with events. You'll have to adapt the proportion value (right now it is in meters, and it should be a value between 0 and 1, dependent on border length.)
events_sharedborder <- data.frame()
for (i in 1:n) {
for (j in 1:n) {
border <- as.numeric(border_length(i, j, counties_shp_clean))
if (border > 0) {
print(paste(i,j,border))
events_sharedborder <- rbind(events_sharedborder,data.frame(event = 'extTrans',
node = i,
dest = j,
n = 0,
proportion = border
select=1,
events_sharedborder <- data.frame()
for (i in 1:n) {
for (j in 1:n) {
border <- as.numeric(border_length(i, j, counties_shp_clean))
if (border > 0) {
print(paste(i,j,border))
events_sharedborder <- rbind(events_sharedborder,data.frame(event = 'extTrans',
node = i,
dest = j,
n = 0,
proportion = border,
select=1,
shift=0))
}
warnings()
saveRDS(events_sharedborder,"data/events_sharedborder.RDS")
centroids <- st_centroid(counties_shp_clean)
centroids
events_sharedborder
centroids
centroids$node <- 1:nrow(centroids)
centroids$node
centroids$GET_END_YE
sort(centroids$GET_END_YE)
centroids
centroids <- dplyr::select(centroids,node,G_NAME,geometry)
centroids
plot(centroids)
events_distance <- data.frame()
st_distance(3, 4, counties_shp_clean)
counties_shp_clean[4]
counties_shp_clean[[4]]
counties_shp_clean[4,]
st_distance(counties_shp_clean[4,],counties_shp_clean[5,])
st_distance(counties_shp_clean[4,],counties_shp_clean[15,])
# Calculate distance
events_distance <- data.frame()
for (i in 1:n) {
for (j in 1:n) {
dist <- as.numeric(st_distance(i, j, counties_shp_clean))
if (dist > 0) {
print(paste(i,j,dist))
events_distance <- rbind(events_distance,data.frame(event = 'extTrans',
node = i,
dest = j,
n = 0,
proportion = dist,
select=1,
shift=0))
}
centroids
st_distance(centroids[4,],centroids[15,])
events_distance <- data.frame()
for (i in 1:n) {
for (j in 1:n) {
dist <- as.numeric(st_distance(centroids[i,],centroids[j,]))
if (dist > 0) {
print(paste(i,j,dist))
events_distance <- rbind(events_distance,data.frame(event = 'extTrans',
node = i,
dest = j,
n = 0,
proportion = dist,
select=1,
shift=0))
}
#install.packages("sf")
#install.packages("spdep")
#install.packages("lwgeom")
#install.packages("readr")
library(sf)
library(spdep)
library(lwgeom)
library(tidyr)
library(readr)
# Read in your shapefile
counties_shp <- st_read("data/ParishesScania.shp")
counties_shp <- st_set_crs(counties_shp,st_crs(3035))
# Plot your shapefile
plot(counties_shp)
# Check shapefile. 1 not valid, 437 valid.
table(st_is_valid(counties_shp))
# Clean up shapefile
counties_shp_clean <- st_make_valid(counties_shp, reason = TRUE)
# Plot again. Not that i see a difference.
plot(counties_shp_clean)
# Calculate the centroids of all parishes
centroids <- st_centroid(counties_shp_clean)
centroids
centroids$geometry
table(centroids$geometry)
table(counties_shp_clean$G_NAME)
as.data.frame(table(counties_shp_clean$G_NAME))
duplicates <- as.data.frame(table(counties_shp_clean$G_NAME)) %>% dplyr::filter(Freq > 1) %>% pull(Var1)
duplicates <- as.data.frame(table(counties_shp_clean$G_NAME)) %>% dplyr::filter(Freq > 1) %>% dplyr::pull(Var1)
duplicates
dplyr::filter(counties_shp_clean,G_NAME %in% duplicates)
duplicates <- dplyr::filter(counties_shp_clean,G_NAME %in% duplicates)
duplicates
counties_shp_clean <- dplyr::filter(counties_shp_clean,GET_END_YE >= 1714, GET_START_ <= 1711)
counties_shp_clean
# Read in your shapefile
counties_shp <- st_read("data/ParishesScania.shp")
counties_shp <- st_set_crs(counties_shp,st_crs(3035))
# Plot your shapefile
plot(counties_shp)
# Check shapefile. 1 not valid, 437 valid.
table(st_is_valid(counties_shp))
# Clean up shapefile
counties_shp_clean <- st_make_valid(counties_shp, reason = TRUE)
# Plot again. Not that i see a difference.
plot(counties_shp_clean)
# Some names are duplicates. This is in part when shapes change over time.
# Our time period of interest is 1711-1714, so shapes that end before that period, or start after are no longer of relevance.
duplicates <- as.data.frame(table(counties_shp_clean$G_NAME)) %>% dplyr::filter(Freq > 1) %>% dplyr::pull(Var1)
duplicates <- dplyr::filter(counties_shp_clean,G_NAME %in% duplicates)
counties_shp_clean
duplicates
counties_shp_clean <- dplyr::filter(counties_shp_clean,GET_END_YE >= 1714)
counties_shp_clean <- dplyr::filter(counties_shp_clean,is.na(GET_START_) | GET_START_ <= 1711)
duplicates <- as.data.frame(table(counties_shp_clean$G_NAME)) %>% dplyr::filter(Freq > 1) %>% dplyr::pull(Var1)
duplicates
within_matrix <- st_within(counties_shp_clean, counties_shp_clean, sparse = FALSE)
within_indices <- apply(within_matrix, 1, function(row) any(row == 1))
within_polygons <- polygons1[within_indices, ]
within_polygons <- counties_shp_clean[within_indices, ]
within_polygons
#install.packages("sf")
#install.packages("spdep")
#install.packages("lwgeom")
#install.packages("readr")
library(sf)
library(spdep)
library(lwgeom)
library(tidyr)
library(readr)
# Read in your shapefile
counties_shp <- st_read("data/ParishesScania.shp")
counties_shp <- st_set_crs(counties_shp,st_crs(3035))
# Plot your shapefile
plot(counties_shp)
# Check shapefile. 1 not valid, 437 valid.
table(st_is_valid(counties_shp))
# Clean up shapefile
counties_shp_clean <- st_make_valid(counties_shp, reason = TRUE)
# Plot again. Not that i see a difference.
plot(counties_shp_clean)
# Some names are duplicates. This is in part when shapes change over time.
# Our time period of interest is 1711-1714, so shapes that end before that period, or start after are no longer of relevance.
duplicates <- as.data.frame(table(counties_shp_clean$G_NAME)) %>% dplyr::filter(Freq > 1) %>% dplyr::pull(Var1)
duplicates <- dplyr::filter(counties_shp_clean,G_NAME %in% duplicates)
counties_shp_clean <- dplyr::filter(counties_shp_clean,GET_END_YE >= 1714)
counties_shp_clean <- dplyr::filter(counties_shp_clean,is.na(GET_START_) | GET_START_ <= 1711)
# Check for duplicates again in name.
duplicates <- as.data.frame(table(counties_shp_clean$G_NAME)) %>% dplyr::filter(Freq > 1) %>% dplyr::pull(Var1)
counties_shp_clean$node <- 1:nrow(counties_shp_clean)
# Calculate the shared borders between all parishes.
shared_borders <- st_touches(counties_shp_clean, sparse = FALSE)
#install.packages("sf")
#install.packages("spdep")
#install.packages("lwgeom")
#install.packages("readr")
library(sf)
library(spdep)
library(lwgeom)
library(tidyr)
library(readr)
# Read in your shapefile
counties_shp <- st_read("data/ParishesScania.shp")
counties_shp <- st_set_crs(counties_shp,st_crs(3035))
# Plot your shapefile
plot(counties_shp)
# Check shapefile. 1 not valid, 437 valid.
table(st_is_valid(counties_shp))
# Clean up shapefile
counties_shp_clean <- st_make_valid(counties_shp, reason = TRUE)
# Plot again. Not that i see a difference.
plot(counties_shp_clean)
# Some names are duplicates. This is in part when shapes change over time.
# Our time period of interest is 1711-1714, so shapes that end before that period, or start after are no longer of relevance.
duplicates <- as.data.frame(table(counties_shp_clean$G_NAME)) %>% dplyr::filter(Freq > 1) %>% dplyr::pull(Var1)
duplicates <- dplyr::filter(counties_shp_clean,G_NAME %in% duplicates)
counties_shp_clean <- dplyr::filter(counties_shp_clean,GET_END_YE >= 1714)
counties_shp_clean <- dplyr::filter(counties_shp_clean,is.na(GET_START_) | GET_START_ <= 1711)
# Check for duplicates again in name.
duplicates <- as.data.frame(table(counties_shp_clean$G_NAME)) %>% dplyr::filter(Freq > 1) %>% dplyr::pull(Var1)
# Store indices of the cleaned shapefile.
counties_shp_clean$node <- 1:nrow(counties_shp_clean)
# Store the cleaned shapefile.
saveRDS(counties_shp_clean,"data/scania_geometry.RDS")
# Calculate the shared borders between all parishes.
shared_borders <- st_touches(counties_shp_clean, sparse = FALSE)
# Get shared border length
border_length <- function(i, j, counties_shp_clean) {
if (shared_borders[i, j]) {
intersection <- st_intersection(counties_shp_clean[i,], counties_shp_clean[j,])
return(st_length(intersection))
}
return(0)
}
# Build an event dataframe, but without a time axis yet.
n <- nrow(counties_shp_clean)
# Fill the a dataframe with events. The proportion field will have to be scaled. Right now it is the border in meters, and it should be a value between 0 and 1.
events_sharedborder <- data.frame()
for (i in 1:n) {
for (j in 1:n) {
border <- as.numeric(border_length(i, j, counties_shp_clean))
if (border > 0) {
print(paste(i,j,border))
events_sharedborder <- rbind(events_sharedborder,data.frame(event = 'extTrans',
node = i,
dest = j,
n = 0,
proportion = border,
select=1,
shift=0))
}
# Store dataframe object
saveRDS(events_sharedborder,"data/events_sharedborder.RDS")
# Add the node, for looking up in events_sharedborder
centroids$node <- 1:nrow(centroids)
centroids <- st_centroid(counties_shp_clean)
# Add the node, for looking up in events_sharedborder
centroids$node <- 1:nrow(centroids)
# Visualize
plot(centroids)
# Calculate distance
events_distance <- data.frame()
for (i in 1:n) {
for (j in 1:n) {
dist <- as.numeric(st_distance(centroids[i,],centroids[j,]))
if (dist > 0) {
print(paste(i,j,dist))
events_distance <- rbind(events_distance,data.frame(event = 'extTrans',
node = i,
dest = j,
n = 0,
proportion = dist,
select=1,
shift=0))
}
events_distance <- data.frame()
for (i in 1:n) {
for (j in 1:n) {
dist <- as.numeric(st_distance(centroids[i,],centroids[j,]))
border <- as.numeric(border_length(i, j, counties_shp_clean))
if (dist > 0 & border > 0) {
print(paste(i,j,dist))
events_distance <- rbind(events_distance,data.frame(event = 'extTrans',
node = i,
dest = j,
n = 0,
proportion = dist,
select=1,
shift=0))
}
events_distance <- data.frame()
for (i in 1:n) {
for (j in 1:n) {
border <- as.numeric(border_length(i, j, counties_shp_clean))
if (border > 0) {
dist <- as.numeric(st_distance(centroids[i,],centroids[j,]))
print(paste(i,j,dist))
events_distance <- rbind(events_distance,data.frame(event = 'extTrans',
node = i,
dest = j,
n = 0,
proportion = dist,
select=1,
shift=0))
}
View(events_distance)
min(events_distance$proportion)
saveRDS(events_distance,"data/events_distances.RDS")
