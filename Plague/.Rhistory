break # Breaks the innermost loop when the condition is met
}
}
}
}
error[i] <- (infected_parishes[i] - cum_infected_parishes_by_month[i,'NumberInfectedParishes'])^2
}
# Computing the error between the model's output and the data
total_error <- (1/length(cum_infected_parishes_by_month)) * (1/total_parishes)^2 * sum(error)
return(total_error)
}
# Extract the best parameters
best_params <- res$x
# Plot the cumulative number of parishes per month using the model estimation
plot_infected_parishes_model(best_params, YSTAD_group, 0)
knitr::opts_chunk$set(echo = TRUE)
reticulate::repl_python()
library(ggplot2)
library(lubridate)
library(dplyr)
library(readr) # for read csv files
library(groundhog)
pkgs <- c("conflicted","SimInf","ggplot2","dplyr","mlrMBO")
groundhog.library(pkgs, "2023-04-30")
conflicts_prefer(dplyr::filter)
# to interact with Python
library(reticulate)
path_project_plague <- "/Users/dianapli/Desktop/PythonMathematicalModeling/docs/PlagueProject"
source_python(paste0(path_project_plague, "/funct_process_data.py"))
YSTAD_group <- read_csv("/Users/dianapli/Desktop/PythonMathematicalModeling/docs/PlagueProject/data/private/yellow_group.csv", col_types = cols())
parish_names <- YSTAD_group$ParishName
patchPop <- YSTAD_group$BEF1699
maxDays <- max(YSTAD_group$EndDaysPlague)
# generating the initial conditions for the model
npatches <- length(parish_names)
S0 <- rep(0, npatches)
E0 <- rep(0, npatches)
R0 <- rep(0, npatches)
D0 <- rep(0, npatches)
I0 <- rep(0, npatches)
I0[1] <- 1.0
for (i in 1:npatches) {
S0[i] <- patchPop[i] - E0[i] - I0[i] - R0[i]
}
u0 <- data.frame(
S0 = S0,
E0 = E0,
I0 = I0,
R0 = R0,
D0 = D0
)
# SEIRD model.
transitions <- c(
"S-> beta*S*I/(S+E+I+R) -> E",
"E -> sigma*E -> I",
"I -> gamma*(1-mu)*I -> R",
"I -> (gamma*mu)*I -> D"
)
compartments <- c("S", "E", "I", "R", "D")
parameters <- c("beta", "mu")
colnames(u0) <- compartments
# EMatrix (#compartments x #events). For each column vector j we put 1 if the compartment
# participated in the event j, otherwise zero.
E <- matrix(
c(0, 1, 1, 0, 0),
nrow = 5,
ncol = 1,
dimnames = list(c("S", "E", "I", "R", "D"),
c("event1"))
)
grav_matrix <- read_csv("/Users/dianapli/Desktop/PythonMathematicalModeling/docs/PlagueProject/data/private/matrix_yellow_group.csv", col_types = cols())
# Assign column names
colnames(grav_matrix) <- parish_names
# Create an external transfer event to move exposed or infected individuals
# from node 1 (Ystad) to other nodes starting seven days after the initial plague
# period in Ystad and every seven days until proportional to the gravity term
data_init_node <- subset(YSTAD_group, ParishName == "YSTAD")
initial_time <- data_init_node$BeginDaysPlague[1]
# Initialize an empty list
list_of_events2 <- list()
for(i in 2:npatches){
infect_event2 <-
lapply(seq(from = initial_time + 7, to = maxDays, by = 7),
function(t) {
data.frame(
event = "extTrans",
time = t,
node = 1,
dest = i,
n = 0,
proportion = grav_matrix$YSTAD[i],
select = 1,
shift = 0
)
})
# Append the events to list_of_events2
# list_of_events2 is a list of lists of dataframes
list_of_events2[[i]] <- infect_event2
}
events <- do.call(rbind, unlist(list_of_events2, recursive = FALSE))
# call a file in R to use some functions
source("Number_Infected_Parishes.R")
count_infected_parishes_month(YSTAD_group, 'JUN 1712', 0)
plot_parishes_month(YSTAD_group, 'JUN 1712', 0)
# Function to calculate the error in the cumulative number of infected parishes per month
objectiveFunction_2 <- function(parameters, gdf, n) {
model_SEIRD <- mparse(transitions = transitions,
compartments = compartments,
gdata = c(sigma = 0.17 , gamma = 0.4),
ldata = parameters,
u0 = u0,
tspan = 1:maxDays,
events = events,
E = E
)
result <- run(model = model_SEIRD)
traj_D <- trajectory(model = result, compartments = "D")
# Defining the initial date of the gdf to start counting the number of infected parishes per month
date <- gdf$BeginPlaguePeriod[1] # Initial
# Getting the number of infected parishes per month from the data
cum_infected_parishes_by_month <- count_infected_parishes_month(gdf,date,n)
# Initializing the number of infected parishes per month for the model's output
infected_parishes <- rep(0, length(cum_infected_parishes_by_month))
# Initializing the error between the model's output and the data
error <- rep(0, length(cum_infected_parishes_by_month))
# Computing the total number of parishes in the dataframe without repetitions
total_parishes <- length(gdf$ParishName)
# Computing the number of infected parishes per month from the model's output
# i is the month. k is the parish. day is the day of the month
for (i in 1:length(cum_infected_parishes_by_month)) {
init_days <- cum_infected_parishes_by_month[i,'DaysFromInitDate']
final_days <- cum_infected_parishes_by_month[i,'DaysToEndOfMonth']
for (k in 1:total_parishes) {
for (day in init_days:final_days) {
# Check if there are any rows that satisfy the condition
rows <- traj_D[traj_D$node == k & traj_D$time == day,]
# rows represent the solution of the model at time t for node k
if (nrow(rows) == 0){
break # Breaks the innermost loop when the condition is met
}
else if(nrow(rows) > 0){
if(rows$D >= 1){
infected_parishes[i] <- infected_parishes[i] + 1
break # Breaks the innermost loop when the condition is met
}
}
}
}
error[i] <- (infected_parishes[i] - cum_infected_parishes_by_month[i,'NumberInfectedParishes'])^2
}
# Computing the error between the model's output and the data
total_error <- (1/length(cum_infected_parishes_by_month)) * (1/total_parishes)^2 * sum(error)
return(total_error)
}
ncopies<-50
ps<- makeParamSet(
makeNumericVectorParam("beta", len=npatches, lower = 0, upper = 1),
makeNumericVectorParam("mu",len=npatches, lower = 0, upper = 1)
)
# Generate an initial design
des <- generateDesign(n = ncopies, par.set = ps)
# Define the objective function for mlrMBO
objectiveFunction_2_mlr <- makeSingleObjectiveFunction(
name = "My Function",
noisy = TRUE,
has.simple.signature= TRUE,
fn = function(xs){
beta <- rep(0, npatches)
K <- 1
for (I in 1:npatches){
beta[K] <- xs[I]
K <- K + 1
}
mu <- rep(0, npatches)
K <- 1
for (I in (npatches+1):(2*npatches)){
mu[K] <- xs[I]
K <- K + 1
}
# now, make a df such that the columns are the vectors beta and mu
beta <- as.data.frame(beta)
mu <- as.data.frame(mu)
beta_mu <- cbind(beta, mu)
colnames(beta_mu) <- c("beta", "mu")
return (objectiveFunction_2(parameters = beta_mu
, gdf = YSTAD_group, n = 0))},
par.set = ps,
minimize = TRUE
)
control = makeMBOControl()
control = setMBOControlTermination(control, iters = 50)
control = setMBOControlInfill(control, crit = makeMBOInfillCritEI())  # Not sure if this is the default, or something Avelda added.
des$y = apply(des,1,objectiveFunction_2_mlr)
# Run the optimization
res <- mbo(fun = objectiveFunction_2_mlr, design = des, control = control, show.info = TRUE)
# Extract the best parameters
best_params <- res$x
# Plot the cumulative number of parishes per month using the model estimation
plot_infected_parishes_model(best_params, YSTAD_group, 0)
# call a file in R to use some functions
source("Number_Infected_Parishes.R")
count_infected_parishes_month(YSTAD_group, 'JUN 1712', 0)
plot_parishes_month(YSTAD_group, 'JUN 1712', 0)
# Extract the best parameters
best_params <- res$x
# Plot the cumulative number of parishes per month using the model estimation
plot_infected_parishes_model(best_params, YSTAD_group, 0)
res$y
date <- YSTAD_group$BeginPlaguePeriod[1]
date <- min(YSTAD_group$BeginPlaguePeriod, na.rm = TRUE)
date <- min(YSTAD_group$BeginPlaguePeriod, na.rm = TRUE)
date
library(ggplot2)
library(lubridate)
library(dplyr)
library(readr) # for read csv files
# Function to count the number of parishes affected by the plague per month
count_infected_parishes_month <- function(df, date, n
, column_name = 'ParishName'
, start_date = 'BeginPlaguePeriod'
, end_date = 'EndPlaguePeriod') {
# Convert your date columns to datetime format
df[[start_date]] <- parse_date_time(df[[start_date]], orders = "my")
df[[end_date]] <- parse_date_time(df[[end_date]], orders = "my", quiet = TRUE)
# Replace NA with corresponding date in start_date column plus n months
df[[end_date]][is.na(df[[end_date]])] <- df[[start_date]][is.na(df[[end_date]])] %m+% months(n)
# Convert your date to datetime format
date <- parse_date_time(date, orders = "my")
# Add the converted date to a new column in df
df$ConvertedDate <- date
# Check if there is at least one non-NA date in end_date column
if (any(!is.na(df[[end_date]]))) {
# Define the range of dates
dates <- seq(from = date, to = max(df[[end_date]], na.rm = TRUE), by = "month")
# Create a unique identifier combining Parish and date ranges
df$UniqueID <- paste0(df[[column_name]], '_', df[[start_date]], '_', df[[end_date]])
# Create a dataframe to store the results
results <- data.frame(Month = dates,
DaysFromInitDate = as.numeric(dates - min(df[[start_date]]), units="days"),
NumberInfectedParishes = 0,
CumInfectParishes = 0,
EndOfMonth = dates + months(1) - days(1))
# Initialize an empty list to store the sets of infected parishes
infected_parishes <- vector("list", length(dates))
# Iterate over the dates
for (i in 1:length(dates)) {
date <- dates[i]
# Count nodes where infection start date is before or on the given date
# and either there is no end date or the end date is after the given date
infected_nodes <- df[(df[[start_date]] <= date) & (df[[end_date]] >= date), ]
# Store the results
results[results$Month == date, 'NumberInfectedParishes'] <- length(unique(infected_nodes$UniqueID))
# Add the set of infected parishes to the list
infected_parishes[[i]] <- unique(infected_nodes[[column_name]])
}
# Initialize cum_infect_parishes as a vector filled with 0s and the same length as dates
cum_infect_parishes <- rep(0, length(dates))
# Check if the first set of infected parishes is non-empty
if (length(infected_parishes[[1]]) > 0) {
cum_infect_parishes[1] <- length(infected_parishes[[1]])
# Defining a variable to store the union of the infected parishes
union_infected_parishes <- unique(infected_parishes[[1]])
} else {
union_infected_parishes <- c()  # Empty vector in R
}
} else {
stop("All values in the end_date column are NA. Cannot create a sequence of dates.")
}
# Add a new column to count the days from the initial date to the end of the month
results$DaysToEndOfMonth <- as.integer(results$EndOfMonth - min(df[[start_date]]))
# Add a new column with the sets of infected parishes
results$InfectedParishes <- infected_parishes
# Calculate the cumulative number of infected parishes by month using the sets
cum_infect_parishes <- as.integer(length(dates))
cum_infect_parishes[1] <- length(infected_parishes[[1]])
for (i in 2:length(infected_parishes)) {
if (length(intersect(infected_parishes[[i]], infected_parishes[[i-1]])) == 0) {
cum_infect_parishes[i] <- cum_infect_parishes[i-1]
} else {
cum_infect_parishes[i] <- cum_infect_parishes[i-1] + length(setdiff(infected_parishes[[i]], infected_parishes[[i-1]]))
}
}
# Add a new column with the cumulative number of infected parishes
results$CumInfectParishes <- cum_infect_parishes
return(results)
}
plot_parishes_month <- function(df, date, n, column_name = 'ParishName', start_date = 'BeginPlaguePeriod', end_date = 'EndPlaguePeriod') {
results <- count_infected_parishes_month(df, date, n, column_name, start_date, end_date)
# Ensure 'date' exists in 'results' and not 'df'
if(!"Month" %in% names(results)) {
stop("Error: 'date' column not found in 'results'")
}
results$Month <- as.Date(results$Month, format="%b %Y")
ggplot(results, aes(x=Month, y=NumberInfectedParishes)) +
geom_line(color='orange') +
scale_x_date(labels = scales::date_format("%b %Y")) +
labs(x='Month', y='No. infected parishes', title='South Scania') +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
}
# Plot the results
plot_infected_parishes_model <- function(best_params, gdf, n) {
# Create a data frame with the best parameters
df_best_params <- as.data.frame(best_params)
# Evaluate the model in the best parameters
model_SEIRD <- mparse(transitions = transitions,
compartments = compartments,
gdata = c(sigma = 0.17 , gamma = 0.4),
ldata = df_best_params,
u0 = u0,
tspan = 1:maxDays,
events = events,
E = E
)
result <- run(model = model_SEIRD)
traj_D <- trajectory(model = result, compartments = "D")
# Defining the initial date of the gdf to start counting the number of infected parishes per month
# date <- min(gdf$BeginPlaguePeriod, na.rm = TRUE) # This is not giving the correct date
date <- gdf$BeginPlaguePeriod[1] # Initial. works if gdf is sorted by BeginPlaguePeriod
# Getting the number of infected parishes per month from the data
cum_infected_parishes_by_month <- count_infected_parishes_month(gdf,date,n)
# Initializing the number of infected parishes per month for the model's output
infected_parishes <- rep(0, length(cum_infected_parishes_by_month$Month))
# Computing the total number of parishes in the dataframe without repetitions
total_parishes <- length(gdf$ParishName)
# Computing the number of infected parishes per month from the model's output
for (i in 1:length(cum_infected_parishes_by_month)) {
init_days <- cum_infected_parishes_by_month[i,'DaysFromInitDate']
final_days <- cum_infected_parishes_by_month[i,'DaysToEndOfMonth']
for (k in 1:total_parishes) {
for (day in init_days:final_days) {
# Check if there are any rows that satisfy the condition
rows <- traj_D[traj_D$node == k & traj_D$time == day, ]
if (nrow(rows) == 0){
break # Breaks the innermost loop when the condition is met
}
else if(nrow(rows) > 0){
if(rows$D >= 1){
infected_parishes[i] <- infected_parishes[i] + 1
break # Breaks the innermost loop when the condition is met
}
}
}
}
}
# Create a new dataframe to store infected parishes and date
df <- data.frame(
"month" = cum_infected_parishes_by_month$Month,
"infected_parishes" = infected_parishes
)
# Plot the results
df$month <- as.Date(df$month, format="%b %Y")
ggplot(df, aes(x=month)) +
# Model estimation
geom_line(aes(y=infected_parishes), color='blue') +
# Real data
geom_line(aes(y=cum_infected_parishes_by_month$NumberInfectedParishes), color='orange') +
scale_x_date(labels = scales::date_format("%b %Y")) +
#scale_y_continuous(limits = c(0,total_parishes))+
labs(x='Month', y='No. infected parishes', title='South Scania') +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
}
count_deaths_by_month <- function(gdf, column_name = 'ParishName'
, begin_date = 'BeginPlaguePeriod'
, victims_column = 'VictimsNumber'
, end_date = 'EndPlaguePeriod'
, pop_size = 'BEF1699') {
# Create a copy of the dataframe
gdf_copy <- gdf
# Filter the dataframe to get only the infected parishes
gdf_copy <- gdf_copy[!is.na(gdf_copy[[begin_date]]), ]
# Fixing the type of the column to iterate over
gdf_copy$new_format_BeginPlaguePeriod <- as.Date(gdf_copy$new_format_BeginPlaguePeriod, format="%Y-%m-%d")
gdf_copy$new_format_EndPlaguePeriod <- as.Date(gdf_copy$new_format_EndPlaguePeriod, format="%Y-%m-%d")
# Sort by the column
gdf_copy <- gdf_copy[order(gdf_copy$new_format_BeginPlaguePeriod),]
# adding a column with the number of days from the beginning of the plague
gdf_copy$BeginDaysPlague <- as.integer(gdf_copy$new_format_BeginPlaguePeriod - min(gdf_copy$new_format_BeginPlaguePeriod))
# Adding a column with the number of days to the end of the plague
gdf_copy$EndDaysPlague <- sapply(1:nrow(gdf_copy), function(i) {
if (!is.na(as.Date(gdf_copy$new_format_EndPlaguePeriod[i]))) {
return(as.integer(as.Date(gdf_copy$new_format_EndPlaguePeriod[i])
- as.Date(gdf_copy$new_format_BeginPlaguePeriod[1])))
} else {
return(NA)
}
})
# Fix the type of pop_size to integer
gdf_copy[[pop_size]] <- as.integer(gdf_copy[[pop_size]])
# Get the gdf sorted by the end of the plague period
gdf_copy <- gdf_copy[order(gdf_copy$new_format_EndPlaguePeriod),]
# Get the unique dates
months <- unique(gdf_copy$new_format_EndPlaguePeriod)
days <- unique(gdf_copy$EndDaysPlague)
# Filter out the NA values from months
months <- months[!is.na(months)]
days <- days[!is.na(days)]
# Create a dataframe to store the results
results <- data.frame(EndMonth = months,
CumDays = days,
NumberDeaths = 0,
CumDeaths = 0,
CumPop = 0,
Parishes = "")
# Initialize total_deaths
total_deaths <- 0
# Iterate over the dates
for (date in months) {
# Subset rows where new_format_EndPlaguePeriod is equal to date
subset_df <- gdf_copy[gdf_copy$new_format_EndPlaguePeriod == date, ]
# Calculate number of deaths
numberOfDeaths <- sum(subset_df[[victims_column]], na.rm = TRUE)
# Get parishes
parishes <- paste(gdf_copy[gdf_copy$new_format_EndPlaguePeriod <= date, column_name], collapse = ",")
# Update results dataframe
results[results$EndMonth == date, "Parishes"] <- parishes
results[results$EndMonth == date, "NumberDeaths"] <- numberOfDeaths
# Update total_deaths
total_deaths <- total_deaths + numberOfDeaths
results[results$EndMonth == date, "CumDeaths"] <- total_deaths
# Update CumPop
results[results$EndMonth == date, "CumPop"] <- sum(gdf_copy[gdf_copy$new_format_EndPlaguePeriod <= date, pop_size], na.rm = TRUE)
}
return(results)
}
plot_cum_deaths_by_month <- function(df) {
results <- count_deaths_by_month(df)
ggplot(results, aes(x=EndMonth, y=CumDeaths)) +
geom_line(color='orange') +
scale_x_date(date_labels = "%b %Y") +
labs(x='Month', y='Cum. number of deaths', title='South Scania') +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
}
# Import the csv file
infectedParishes <- read.csv("/Users/dianapli/Desktop/PythonMathematicalModeling/docs/PlagueProject/data/private/infectedSouthParishes.csv")
# Testing the function with a small example
# Filter rows where ParishName is 'YSTAD', 'ÖJA' or 'HEDESKOGA'
example1 <- infectedParishes[infectedParishes$ParishName %in% c('YSTAD', 'ÖJA', 'HEDESKOGA', 'ELJARÖD'), ]
plot_cum_deaths_by_month(example1)
# ### Objective Functions
#
# # Function to calculate the error in the cumulative number of infected parishes per month between the model and the data
# objectiveFunction_2 <- function(gdf = example, column_name = "ParishName", n = 0) {
#
#   # Defining the initial date of the gdf to start counting the number of infected parishes per month
#   date <- min(gdf$BeginPlaguePeriod, na.rm = TRUE)
#   #
#   # Getting the number of infected parishes per month from the data
#   cum_infected_parishes_by_month <- count_infected_by_month(gdf,date,n)
#
#   # Initializing the number of infected parishes per month for the model's output
#   infected_parishes <- rep(0, length(cum_infected_parishes_by_month))
#
#   # Initializing the error between the model's output and the data
#   error <- rep(0, length(cum_infected_parishes_by_month))
#
#   # Computing the total number of parishes in the dataframe without repetitions
#   total_parishes <- length(gdf[[column_name]])
#
#   # Computing the number of infected parishes per month from the model's output
#   for (i in 1:length(cum_infected_parishes_by_month)) {
#     init_days <- cum_infected_parishes_by_month[i,'DaysFromInitDate']
#     final_days <- cum_infected_parishes_by_month[i,'DaysToEndOfMonth']
#
#     for (k in 1:length(grouped_by_parish)) {
#       for (day in init_days:final_days) {
#         value_D_subset <- traj[traj$node == k & traj$time == day, ]$D
#
#         # Check if the subset operation returned an empty vector
#         if (length(value_D_subset) > 0) {
#           value_D <- value_D_subset >= 1
#
#           if (value_D) {
#             infected_parishes[i] <- infected_parishes[i] + 1
#             break # Breaks the innermost loop when the condition is met
#           }
#         }
#       }
#     }
#     error[i] <- abs(infected_parishes[i] - cum_infected_parishes_by_month[i,'CumInfectParishes'])
#   }
#
#
#   # Computing the error between the model's output and the data
#   total_error <- (1/length(cum_infected_parishes_by_month)) * (1/total_parishes) * sum(error)
#
#   return(list(total_parishes, infected_parishes, error, total_error))
# }
# call a file in R to use some functions
source("Number_Infected_Parishes.R")
count_infected_parishes_month(YSTAD_group, 'JUN 1712', 0)
plot_parishes_month(YSTAD_group, 'JUN 1712', 0)
# call a file in R to use some functions
source("Number_Infected_Parishes.R")
count_infected_parishes_month(YSTAD_group, 'JUN 1712', 0)
plot_parishes_month(YSTAD_group, 'JUN 1712', 0)
# Extract the best parameters
best_params <- res$x
best_solution <- res$y
# Plot the cumulative number of parishes per month using the model estimation
plot_infected_parishes_model(best_params, YSTAD_group, 0)
# Extract the best parameters
best_params <- res$x
best_solution <- res$y
# Plot the cumulative number of parishes per month using the model estimation
plot_infected_parishes_model(best_params, YSTAD_group, 0)
# Extract the best parameters
best_params <- res$x
best_solution <- res$y
# Plot the cumulative number of parishes per month using the model estimation
plot_infected_parishes_model(best_params, YSTAD_group, 0)
knitr::opts_chunk$set(echo = TRUE)
reticulate::repl_python()
